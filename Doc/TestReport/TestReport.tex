\documentclass[12pt, titlepage]{article}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}
\usepackage[round]{natbib}
\title{SE 3XA3: Test Report\\Title of Project}
\author{Team \#, Team Name
		\\ Student 1 name and macid
		\\ Student 2 name and macid
		\\ Student 3 name and macid
}
\date{\today}
\input{../Comments}
\begin{document}
\maketitle
\pagenumbering{roman}
\tableofcontents
\listoftables
\listoffigures
\begin{table}[bp]
\caption{\bf Revision History}
\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Date 1 & 1.0 & Notes\\
Date 2 & 1.1 & Notes\\
\bottomrule
\end{tabularx}
\end{table}
\newpage
\pagenumbering{arabic}
This document ...

\section{Functional Requirements Evaluation}

\subsubsection{Area of Testing 1}		
	\label{sec:3.1.1}
	\paragraph{Requirement \#1: The software shall read data given to it. \\ Requirements \#4: The software will plot all the data points.}
		\begin{enumerate}
			\item{\textbf{Test ID \#1.1\\}}
			\textbf{Type:} Functional, Dynamic, Manual\\
			\textbf{Initial State:} Instantiate Graph(6) object with 6 markings on each quadrant.\\
			\textbf{Input:} The list object: [ (1, 1),  (2, 2), (3, 3), (4, 4) ]\\
			\textbf{Expected Output:} A window depicting a graph with plotted points at (1, 1), (2, 2), (3, 3), and (4, 4). \\
			\textbf{Output:}	A graph with the points (1,1), (2,2), (3,3) and (4,4) was created.\\	
			\textbf{Result:} PASS

					
			\item{\textbf{Test ID \#1.2\\}}
			\textbf{Type:} Functional, Dynamic, Manual\\
			\textbf{Initial State:} None Object.\\
			\textbf{Input:} Instantiate Graph(6, data = [ (1, 1),  (2, 2), (3, 3), (4, 4) ] )\\
			\textbf{Expected Output:} A window depicting a graph with plotted points at (1, 1), (2, 2), (3, 3), and (4, 4). \\
			\textbf{Output:}	A graph with the points (1,1), (2,2), (3,3) and (4,4) was created.\\	
			\textbf{Result:} PASS
				
			\item{\textbf{Test ID \#1.3\\}}
			\textbf{Type:} Functional, Dynamic, Manual\\
			\textbf{Initial State:} Instantiate Graph(6) object with 6 markings on each quadrant.\\
			\textbf{Input:} The list object: [	].\\
			\textbf{Expected Output:} A window depicting a graph with no plotted points.\\
			\textbf{Output:}	An empty graph was outputted.\\
			\textbf{Result:} PASS

			\item{\textbf{Test ID \#1.4\\}}
			\textbf{Type:} Functional, Dynamic, Manual\\
			\textbf{Initial State:} None Object.\\
			\textbf{Input:} Instantiate Graph(6, data = [  ] )\\
			\textbf{Expected Output:} A window depicting a graph with no plotted points.\\
			\textbf{Output:}	An empty graph was outputted.\\
			\textbf{Result:} PASS
	\end{enumerate}

\subsubsection{Area of Testing 2}		
	\paragraph{Requirement \#2: The software will raise an exception if the data format cannot be plotted, and stop the program.}
		\begin{enumerate}
			\item{\textbf{Test ID \#2.1\\}}
			\textbf{Type:} Functional, Dynamic, Manual\\
			\textbf{Initial State:} A testing script that imports the method that validates data. \\
			\textbf{Input:} The list object: [ (1, 1),  (2, 2), (3, 3), (4, 4) ]\\
			\textbf{Expected Output:}  A safe end to the execution (i.e, no exception raised). \\
			\textbf{Output:}	The program completed execution.\\
			\textbf{Result:} PASS
					
			\item{\textbf{Test ID \#2.2\\}}
			\textbf{Type:} Functional, Dynamic, Manual\\
			\textbf{Initial State:} A testing script that imports the method that validates data.\\
			\textbf{Input:} The list object: [ (1, 1),  (2, 2), (3, 3), ( 4 ) ]\\
			\textbf{Expected Output:} The program raised an exception.\\
			\textbf{Output:}	An exception was raised with output in terminal as "Exception: Inconsistent data"\\
			\textbf{Result:} PASS
									
			\item{\textbf{Test ID \#2.3\\}}
			\textbf{Type:} Functional, Dynamic, Manual\\
			\textbf{Initial State:} Instantiate Graph(6) object with 6 markings on each quadrant..\\
			\textbf{Input:} Instantiate Graph(6, data = [ (1, 1),  (2, 2), (3, 3), ( 4 ) ] )\\
			\textbf{Expected Output:} The program raised an exception.\\
			\textbf{Output:}	An exception was raised with output in terminal as "Exception: Inconsistent data"\\
			\textbf{Result:} PASS

	\end{enumerate}

\subsubsection{Area of Testing 3}		
	\paragraph{Requirement \#3: The software will construct a coordinate system that will fit all the data points.}
		\begin{enumerate}
		\label{sec:3.1}
			\item{\textbf{Test ID \#3.1\\}}
			\textbf{Type:} Functional, Dynamic, Manual\\
			\textbf{Initial State:} Instantiate Graph(6) object with 6 markings on each quadrant. \\
			\textbf{Input:} The list object: [ (1, 1),  (2, 2), (3, 3), ( 17, 77) ]\\
			\textbf{Expected Output:}  A window depicting a graph with max x axis value to be 17 and -17, and y axis to include 77 and -77. \\
			\textbf{Output:}	Max y axis was still 6 and -6\\
			\textbf{Result:} FAIL
		\label{sec:3.2}					
			\item{\textbf{Test ID \#3.2\\}}
			\textbf{Type:} Functional, Dynamic, Manual\\
			\textbf{Initial State:}  Instantiate Graph(6) object with 6 markings on each quadrant.\\
			\textbf{Input:} The list object: [ (1, 1),  (2, 2), (3, 3), ( -17, -77) ]\\
			\textbf{Expected Output:} A window depicting a graph with max x axis value to include 17 and -17, and y axis to include 77 and -77. \\
			\textbf{Output:}	Max y axis was still 6 and -6\\
			\textbf{Result:} FAIL

			\textbf{Two more test cases were added to validate the functionality the above test cases were trying to test.}
					
			\item{\textbf{Test ID \#3.3\\}}
			\textbf{Type:} Functional, Dynamic, Manual\\
			\textbf{Initial State:} Instantiate Graph(6) object with 6 markings on each quadrant. \\
			\textbf{Input:} The list object: [ (1, 1),  (2, 2), (3, 3), ( 17, 77) ]\\
			\textbf{Expected Output:} A window depicting a graph with max x axis value include 17 and -17, and y axis to include 77 and -77. \\
			\textbf{Output:}	A graph with all the points plotted, and an x axis from -18 to 18, and y axis from -78 to 87\\
			\textbf{Result:} PASS
								
			\item{\textbf{Test ID \#3.4\\}}
			\textbf{Type:} Functional, Dynamic, Manual\\
			\textbf{Initial State:}  None object\\
			\textbf{Input:} Instantiated Graph(6, [ (1, 1),  (2, 2), (3, 3), ( -17, -77) ]\\
			\textbf{Expected Output:} A window depicting a graph with max x axis value include 17 and -17, and y axis to include 77 and -77. \\
			\textbf{Output:}	A graph with all the points plotted, and an x axis from -18 to 18, and y axis from -78 to 87\\
			\textbf{Result:} PASS
	\end{enumerate}

\subsubsection{Area of Testing 4}
	\paragraph{Requirement \#5: The software will connect a line that passes through all the data points if the data points are a function of x.}
		\begin{enumerate}
			\item{\textbf{Test ID \#4.1\\}}
			\textbf{Type:} Functional, Dynamic, Manual\\
			\textbf{Initial State:} An instantiated Graph object. \\
			\textbf{Input:} The default math.sin() function in python.\\
			\textbf{Expected Output:}  A window depicting the sin() graph.\\
			\textbf{Output:}	A graph with the sin wave plotted\\
			\textbf{Result:} PASS
					
			\item{\textbf{Test ID \#4.2\\}}
			\textbf{Type:} Functional, Dynamic, Manual\\
			\textbf{Initial State:} An instantiated Graph object.\\
			\textbf{Input:} The list object: [ (1, 1),  (2, 2), (3, 3), (4, 4) ] on the method plot\_points\_with\_line()\\
			\textbf{Expected Output:} A window depicting a graph with the points plotted, and a line is connecting all points. \\
			\textbf{Output:}	A line passing through the points in the input\\
			\textbf{Result:} PASS
				
			\item{\textbf{Test ID \#4.3\\}}
			\textbf{Type:} Functional, Dynamic, Manual\\
			\textbf{Initial State:}  An instantiated Graph object.\\
			\textbf{Input:} The list object: [ (1, 1),  (2, 2), (3, 3), (3, 4) ] on the method plot\_points\_with\_line().\\
			\textbf{Expected Output:} The software will plot the points but not connect a line through them.\\
			\textbf{Output:}	The points were plotted, but the line was not drawn.\\
			\textbf{Result:} PASS
	\end{enumerate}
	

\section{Nonfunctional Requirements Evaluation}
\subsection{Look and Feel}

Description: These tests were conducted to ensure that the output graphs that are produced by the library are visually appealing to the user. This was a consideration as the library may be used to create graphs that may be used in presentations, reports and other academic or research environments. It is important that the graphs look professional and appealing.\\\\
Test: 7.1 - Pass\\\\
Results: 75\% of the testers said that the graphs produced by the library were visually appealing in the user survey that was conducted. This satisfied the requirement to have at least 70\% of users who find the graphs visually appealing. Since, the requirement was satisfied no changes were required to the implementation


\subsection{Usability}

Description:  This test was used to check of the usability of the library in through a timed task provided to the testers. The goal was to have testers create all the graphs independent of any assistance from the developers except a user guide document. \\\\
Test: 8.1 - Pass\\\\
Result: The goal of being able to create all graphs with only the assistance of the user guide in 20 minutes was achieved by majority of the testers. 83\% of the testers completed the task within the given time frame surpassing the requirement of 80\%.\\\\
Description: This test was to access whether the error messages produced by the library were sufficient in helping the testers identify the error. \\\\
Test: 8.2 - Fail\\\\
Result: The goal of having at least 80\% of users understand the error messages was not achieved as only 75\% of the testers were clearly able to understand the errors and correct them. This means a revision of the error messages must be done and the messages need to be made more clear for user understanding.

		
\subsection{Performance}

Description: This test for performance uses a Sine Function that plots 12000 points to produce a Sine function graph. The standard time library was used to time how long it takes to produce the graph. The aim was to have the graph produced in under 5 seconds\\\\
Test: 9.1 - Pass\\\\
Result: The test returned results that were that suggested that the graphs were created quickly and within the time frame. The test’s original expectation suggested that each graph should be produced in no more than 5 seconds however it only took approximately 1.7 seconds for the graph to be plotted.

\subsection{Operational and Environmental}

Description: The purpose of this test was to ensure that the library is functional on different operating systems given that they have Python 2.7 installed onto the system. On each of the operating systems a test program (that works on the original platform) run on Python.\\\\
Test: 10.1 - Pass\\\\
Result: All operating systems were able to handle the task and in each case graphs were produced without any errors or issues.

	
\section{Comparison to Existing Implementation}	

Description: This test was compare how the XPYCharts and jCharts libraries deal with unexpected inputs. It was expected that the XPYCharts would not be able to deal with this input and an error will result. jCharts library was expected to catch this exception and output a message.\\\\
Test: 11.1 - Pass\\\\
Result: The test shows that the XPYCharts library cannot deal with such inputs and so changes must be made to the how it deals with unexpected inputs. When jCharts was provided with the same input it was able to catch the exception and gave back a message.\\\\
Description:  Goal was to compare the results of entering an empty list of data into the library and compare whether XPYCharts deals with this input in a similar manner to the jCharts library.\\\\
Test: 11.2 - Pass\\\\
Result: Both graphing libraries produced an empty graph when given as input an empty list of data. This means that XPYCharts faithfully recreates this aspect of the jCharts library.\\\\
Description: This test was to compare how the two libraries deal with a long list of repeated inputs. It is expected that a good library would be able to ignore such repetitions and not take a long time by just graphing one of the inputs. In this case it is expected that jCharts would be able to deal with such a situation and would simply ignore the repetitions and not take a long time to make the graph. On the other hand it is expected that XPYCharts will take a considerably long time according to the current implementation. \\\\
Test: 11.3 - Pass\\\\
Result: jCharts was able to quickly graph the input without being stalled out due to the long list of repeated inputs. XPYCharts took considerably longer to graph the same set of inputs. This was the expected output, however it means that changes must be made to the XPYCharts library to deal with such a situation.\\\\
Description: This test is to compare how the two libraries deal with erroneous inputs where some of the values are (x,y,z) coordinates and not just (x,y). Recall the scope of XPYCharts only covers the XY plane. It was expected that in this case XPYCharts would simply avoid the z value and graph the tuple as a XY tuple. jCharts is expected to catch this exception return a message.\\\\
Test: 11.4- Pass\\\\
Result: XPYCharts graphs the tuple as a XY tuple as expected. However this is not ideal as an error message should be produced letting the user know that a (x,y,z) tuple cannot be expected. jCharts gives an error message as expected.\\

\section{Unit Testing}\label{sec:unittest}


\subsubsection{\_get\_translated\_point(self, coord)}		
	\label{sec:4.0.1}
	\paragraph{}
		\begin{enumerate}
			\item{\textbf{Test ID \#1.1\\}}
			\textbf{Initial State:} Instantiate Graph(6) object with 6 markings on each quadrant.\\
			\textbf{Input:} Dictionary with $x:= int \vee float$, $y:= int \vee float$ \\
			\textbf{Assertion:} Function returns an int or float \\
			\textbf{Result:} PASS
			
			\item{\textbf{Test ID \#1.2\\}}
			\textbf{Initial State:} Instantiate Graph(6) object with 6 markings on each quadrant.\\
			\textbf{Input:} Dictionary with $x:= int \vee float$, $y:= int \vee float$ \\
			\textbf{Assertion:} Function appropriately scales given coords \\
			\textbf{Result:} PASS
			
		\end{enumerate}

%ask hatim
\subsubsection{\_Lagrange(self, x)}		
	\label{sec:4.0.2}
	\paragraph{}
		\begin{enumerate}
			\item{\textbf{Test ID \#2.1\\}}
			\textbf{Initial State:} Instantiate Graph(6) object with 6 markings on each quadrant.\\
			\textbf{Assertion:} Function returns a function \\
			\textbf{Result:} PASS
			
			\item{\textbf{Test ID \#2.2\\}}
			\textbf{Initial State:} Instantiate Graph(6) object with 6 markings on each quadrant.\\
			\textbf{Assertion:} Function returns appropriate function \\
			\textbf{Result:} PASS
		\end{enumerate}

\subsubsection{checktype(x, y)}		
	\label{sec:4.0.3}
	\paragraph{}
		\begin{enumerate}
			\item{\textbf{Test ID \#3.1\\}}
			\textbf{Initial State:} Empty script\\
			\textbf{Input:} Set of dictionaries with $x:= int \vee float$, $y:= int \vee float$ \\
			\textbf{Assertion:} Function raises no exception \\
			\textbf{Result:} PASS
			
			\item{\textbf{Test ID \#2.1\\}}
			\textbf{Initial State:} Empty Script.\\
			\textbf{Input:} Set of dictionaries with one member not respecting $x:= int \vee float$, $y:= int \vee float$ \\
			\textbf{Assertion:} Function raises exception \\
			\textbf{Result:} PASS
		\end{enumerate}
		
%ask sarthak
\subsubsection{\_is\_function(data)}		
	\label{sec:4.0.4}
	\paragraph{}
		\begin{enumerate}
			\item{\textbf{Test ID \#4.1\\}}
			\textbf{Initial State:} Empty script\\
			\textbf{Input:}  \\
			\textbf{Assertion:} Returns true \\
			\textbf{Result:} PASS
			

		\end{enumerate}		
		

\subsubsection{clean\_data(data)}		
	\label{sec:4.0.5}
	\paragraph{}
		\begin{enumerate}
			\item{\textbf{Test ID \#5.1\\}}
			\textbf{Initial State:} Empty script\\
			\textbf{Input:} Non tuple-list variable\\
			\textbf{Assertion:} Throws Inconsistent Data error\\
			\textbf{Result:} PASS
			
			\item{\textbf{Test ID \#5.2\\}}
			\textbf{Initial State:} Empty script\\
			\textbf{Input:} Valid data set \\
			\textbf{Assertion:} Returns formatted list of dictionaries\\
			\textbf{Result:} PASS

		\end{enumerate}		

\subsubsection{scale(data\_set, round\_to = 0)}		
	\label{sec:4.0.5}
	\paragraph{}
		\begin{enumerate}
			\item{\textbf{Test ID \#6.1\\}}
			\textbf{Initial State:}Instantiate Graph(6) object with 6 markings on each quadrant.\\
			\textbf{Input:} Set of dictionaries with $x:= int \vee float$, $y:= int \vee float$ \\
			\textbf{Assertion:} Returns max of x and y respectively\\
			\textbf{Result:} PASS
			
			\item{\textbf{Test ID \#5.2\\}}
			\textbf{Initial State:} Empty script\\
			\textbf{Input:} Set of dictionaries with $x:= int \vee float$, $y:= int \vee float$ . round\_to $\neq 0$ \\
			\textbf{Assertion:}  Returns max of x and y respectively. Return values are multiples of round\_to \\
			\textbf{Result:} PASS

		\end{enumerate}	



\section{Changes Due to Testing}

As seen in the Area of Testing \hyperref[sec:3.1]{3.1} and \hyperref[sec:3.2]{3.2} for Functional Requirements Evaluation, the test cases had failed to produce the expected output. 

After manual code evaluation, it was realized by the developers that this was because an instantiated graph defaults to drawing the axes under the assumption of the data given to it. Because the test case was instantiating the Graph object with NoneType data, the graph would default to drawing the axes with a scale of 1 (therefore, the max values of magnitude 6, for the 6 markings). When calling the plot\_...() methods, it would draw on a canvas already painted in the initializer. 

To fix this, a few extra lines were added to the plot\_...() methods where they would call the init() method to reinitialize the graph canvas and paint it with the appropriate axes. 
\textbf{The two test cases passed once these changes were complete.}  
\section{Automated Testing}
Because of the timeframe of the project, the extent of the automated testing was \hyperref[sec:unittest]{unit testing}, and testing of source code (seen in the test case below) using the online tool \href{https://www.pylint.org}{Pylint}.

\subsubsection{Area of Testing 5}		
	\paragraph{Testing of source code.}
		\begin{enumerate}
			\item{\textbf{Test ID \#5.1\\}}
			\textbf{Type:} Functional, Static, Automated\\
			\textbf{Initial State:} Completed source code. \\
			\textbf{Input:} Source code.\\
			\textbf{Expected Output:} Review of source code.\\
			\textbf{Output:}	 \href{run:code_eval.txt} {\underline{log-file}}.\\
			\textbf{Result:} N/A
		\end{enumerate}

It would not have been feasible to do bitmap comparison automated testing for this project because to do so correctly and accurately would have been out of the scope of the project. The developers verified the outputs of the graphs manually to realize that the behavior was up to expectations, and the challenge in the nature of this sort of automated testing would not have been worth the value compared to the time dedicated to it, especially to realize an outcome that was already manually verified.
		

\section{Code Coverage Metrics} %Louis/Sarthak
\bibliographystyle{plainnat}
\bibliography{SRS}
\end{document}