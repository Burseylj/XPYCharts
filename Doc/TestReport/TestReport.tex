\documentclass[12pt, titlepage]{article}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}
\usepackage[round]{natbib}
\title{SE 3XA3: Test Report\\xPycharts}
\author{Team 4, xPy
		\\ Hatim Rehman (rehmah3)
		\\ Louis Bursey (burseylj)
		\\ Sarthak Desai (desaisa3)
}
\date{\today}
\input{../Comments}
\begin{document}
\maketitle
\pagenumbering{roman}
\tableofcontents
\listoftables
\listoffigures
\begin{table}[bp]
\caption{\bf Revision History}
\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Dec. 7, 2016 &  1.0 & Revision 1 \\
\bottomrule
\end{tabularx}
\end{table}

\newpage
\pagenumbering{arabic}


\section{Functional Requirements Evaluation}

\subsubsection{Area of Testing 1}		
	\label{sec:3.1.1}
	\paragraph{Requirement \#1: The software shall read data given to it. \\ Requirements \#4: The software will plot all the data points.}
		\begin{enumerate}
			\item{\textbf{Test ID \#1.1\\}}
			\textbf{Type:} Functional, Dynamic, Manual\\
			\textbf{Initial State:} Instantiate Graph(6) object with 6 markings on each quadrant.\\
			\textbf{Input:} The list object: [ (1, 1),  (2, 2), (3, 3), (4, 4) ]\\
			\textbf{Expected Output:} A window depicting a graph with plotted points at (1, 1), (2, 2), (3, 3), and (4, 4). \\
			\textbf{Output:}A graph with the points (1,1), (2,2), (3,3) and (4,4) was created.\\	
			\textbf{Result:} PASS

					
			\item{\textbf{Test ID \#1.2\\}}
			\textbf{Type:} Functional, Dynamic, Manual\\
			\textbf{Initial State:} None Object.\\
			\textbf{Input:} Instantiate Graph(6, data = [ (1, 1),  (2, 2), (3, 3), (4, 4) ] )\\
			\textbf{Expected Output:} A window depicting a graph with plotted points at (1, 1), (2, 2), (3, 3), and (4, 4). \\
			\textbf{Output:}	A graph with the points (1,1), (2,2), (3,3) and (4,4) was created.\\	
			\textbf{Result:} PASS
				
			\item{\textbf{Test ID \#1.3\\}}
			\textbf{Type:} Functional, Dynamic, Manual\\
			\textbf{Initial State:} Instantiate Graph(6) object with 6 markings on each quadrant.\\
			\textbf{Input:} The list object: [	].\\
			\textbf{Expected Output:} A window depicting a graph with no plotted points.\\
			\textbf{Output:}	An empty graph was outputted.\\
			\textbf{Result:} PASS

			\item{\textbf{Test ID \#1.4\\}}
			\textbf{Type:} Functional, Dynamic, Manual\\
			\textbf{Initial State:} None Object.\\
			\textbf{Input:} Instantiate Graph(6, data = [  ] )\\
			\textbf{Expected Output:} A window depicting a graph with no plotted points.\\
			\textbf{Output:}	An empty graph was outputted.\\
			\textbf{Result:} PASS
	\end{enumerate}

\subsubsection{Area of Testing 2}		
	\paragraph{Requirement \#2: The software will raise an exception if the data format cannot be plotted, and stop the program.}
		\begin{enumerate}
			\item{\textbf{Test ID \#2.1\\}}
			\textbf{Type:} Functional, Dynamic, Manual\\
			\textbf{Initial State:} A testing script that imports the method that validates data. \\
			\textbf{Input:} The list object: [ (1, 1),  (2, 2), (3, 3), (4, 4) ]\\
			\textbf{Expected Output:}  A safe end to the execution (i.e, no exception raised). \\
			\textbf{Output:}	The program completed execution.\\
			\textbf{Result:} PASS
					
			\item{\textbf{Test ID \#2.2\\}}
			\textbf{Type:} Functional, Dynamic, Manual\\
			\textbf{Initial State:} A testing script that imports the method that validates data.\\
			\textbf{Input:} The list object: [ (1, 1),  (2, 2), (3, 3), ( 4 ) ]\\
			\textbf{Expected Output:} The program raised an exception.\\
			\textbf{Output:}	An exception was raised with output in terminal as "Exception: Inconsistent data"\\
			\textbf{Result:} PASS
									
			\item{\textbf{Test ID \#2.3\\}}
			\textbf{Type:} Functional, Dynamic, Manual\\
			\textbf{Initial State:} Instantiate Graph(6) object with 6 markings on each quadrant..\\
			\textbf{Input:} Instantiate Graph(6, data = [ (1, 1),  (2, 2), (3, 3), ( 4 ) ] )\\
			\textbf{Expected Output:} The program raised an exception.\\
			\textbf{Output:}	An exception was raised with output in terminal as "Exception: Inconsistent data"\\
			\textbf{Result:} PASS

	\end{enumerate}

\subsubsection{Area of Testing 3}		
	\paragraph{Requirement \#3: The software will construct a coordinate system that will fit all the data points.}
		\begin{enumerate}
		\label{sec:3.1}
			\item{\textbf{Test ID \#3.1\\}}
			\textbf{Type:} Functional, Dynamic, Manual\\
			\textbf{Initial State:} Instantiate Graph(6) object with 6 markings on each quadrant. \\
			\textbf{Input:} The list object: [ (1, 1),  (2, 2), (3, 3), ( 17, 77) ]\\
			\textbf{Expected Output:}  A window depicting a graph with max x axis value to be 17 and -17, and y axis to include 77 and -77. \\
			\textbf{Output:}	Max y axis was still 6 and -6\\
			\textbf{Result:} FAIL
		\label{sec:3.2}					
			\item{\textbf{Test ID \#3.2\\}}
			\textbf{Type:} Functional, Dynamic, Manual\\
			\textbf{Initial State:}  Instantiate Graph(6) object with 6 markings on each quadrant.\\
			\textbf{Input:} The list object: [ (1, 1),  (2, 2), (3, 3), ( -17, -77) ]\\
			\textbf{Expected Output:} A window depicting a graph with max x axis value to include 17 and -17, and y axis to include 77 and -77. \\
			\textbf{Output:}	Max y axis was still 6 and -6\\
			\textbf{Result:} FAIL

			\textbf{Two more test cases were added to validate the functionality the above test cases were trying to test.}
					
			\item{\textbf{Test ID \#3.3\\}}
			\textbf{Type:} Functional, Dynamic, Manual\\
			\textbf{Initial State:} Instantiate Graph(6) object with 6 markings on each quadrant. \\
			\textbf{Input:} The list object: [ (1, 1),  (2, 2), (3, 3), ( 17, 77) ]\\
			\textbf{Expected Output:} A window depicting a graph with max x axis value include 17 and -17, and y axis to include 77 and -77. \\
			\textbf{Output:}	A graph with all the points plotted, and an x axis from -18 to 18, and y axis from -78 to 87\\
			\textbf{Result:} PASS
								
			\item{\textbf{Test ID \#3.4\\}}
			\textbf{Type:} Functional, Dynamic, Manual\\
			\textbf{Initial State:}  None object\\
			\textbf{Input:} Instantiated Graph(6, [ (1, 1),  (2, 2), (3, 3), ( -17, -77) ]\\
			\textbf{Expected Output:} A window depicting a graph with max x axis value include 17 and -17, and y axis to include 77 and -77. \\
			\textbf{Output:}	A graph with all the points plotted, and an x axis from -18 to 18, and y axis from -78 to 87\\
			\textbf{Result:} PASS
	\end{enumerate}

\subsubsection{Area of Testing 4}
	\paragraph{Requirement \#5: The software will connect a line that passes through all the data points if the data points are a function of x.}
		\begin{enumerate}
			\item{\textbf{Test ID \#4.1\\}}
			\textbf{Type:} Functional, Dynamic, Manual\\
			\textbf{Initial State:} An instantiated Graph object. \\
			\textbf{Input:} The default math.sin() function in python.\\
			\textbf{Expected Output:}  A window depicting the sin() graph.\\
			\textbf{Output:}	A graph with the sin wave plotted\\
			\textbf{Result:} PASS
					
			\item{\textbf{Test ID \#4.2\\}}
			\textbf{Type:} Functional, Dynamic, Manual\\
			\textbf{Initial State:} An instantiated Graph object.\\
			\textbf{Input:} The list object: [ (1, 1),  (2, 2), (3, 3), (4, 4) ] on the method plot\_points\_with\_line()\\
			\textbf{Expected Output:} A window depicting a graph with the points plotted, and a line is connecting all points. \\
			\textbf{Output:}	A line passing through the points in the input\\
			\textbf{Result:} PASS
				
			\item{\textbf{Test ID \#4.3\\}}
			\textbf{Type:} Functional, Dynamic, Manual\\
			\textbf{Initial State:}  An instantiated Graph object.\\
			\textbf{Input:} The list object: [ (1, 1),  (2, 2), (3, 3), (3, 4) ] on the method plot\_points\_with\_line().\\
			\textbf{Expected Output:} The software will plot the points but not connect a line through them.\\
			\textbf{Output:}	The points were plotted, but the line was not drawn.\\
			\textbf{Result:} PASS
	\end{enumerate}
	

\section{Nonfunctional Requirements Evaluation}
\subsection{Look and Feel}

Description: These tests were conducted to ensure that the output graphs that are produced by the library are visually appealing to the user. This was a consideration as the library may be used to create graphs that may be used in presentations, reports and other academic or research environments. It is important that the graphs look professional and appealing.\\\\
Test: 7.1 - Pass\\\\
Results: 75\% of the testers said that the graphs produced by the library were visually appealing in the user survey that was conducted. This satisfied the requirement to have at least 70\% of users who find the graphs visually appealing. Since, the requirement was satisfied no changes were required to the implementation


\subsection{Usability}

Description:  This test was used to check of the usability of the library in through a timed task provided to the testers. The goal was to have testers create all the graphs independent of any assistance from the developers except a user guide document. \\\\
Test: 8.1 - Pass\\\\
Result: The goal of being able to create all graphs with only the assistance of the user guide in 20 minutes was achieved by majority of the testers. 83\% of the testers completed the task within the given time frame surpassing the requirement of 80\%.\\\\
Description: This test was to access whether the error messages produced by the library were sufficient in helping the testers identify the error. \\\\
Test: 8.2 - Fail\\\\ 	\label{sec:8.2}
Result: The goal of having at least 80\% of users understand the error messages was not achieved as only 75\% of the testers were clearly able to understand the errors and correct them. This means a revision of the error messages must be done and the messages need to be made more clear for user understanding.

		
\subsection{Performance}

Description: This test for performance uses a Sine Function that plots 12000 points to produce a Sine function graph. The standard time library was used to time how long it takes to produce the graph. The aim was to have the graph produced in under 5 seconds\\\\
Test: 9.1 - Pass\\\\
Result: The test returned results that were that suggested that the graphs were created quickly and within the time frame. The test’s original expectation suggested that each graph should be produced in no more than 5 seconds however it only took approximately 1.7 seconds for the graph to be plotted.

\subsection{Robustness}
Robustness tests are tested alongside the comparison to existing library tests. Specifically, sections \hyperref[sec:11.1]{11.1}, \hyperref[sec:11.2]{11.2}, \hyperref[sec:11.4]{11.4}. These tests existed to see how jCharts, the original library would deal with erroneous data, which made sense to do. 

\subsection{Operational and Environmental}

Description: The purpose of this test was to ensure that the library is functional on different operating systems given that they have Python 2.7 installed onto the system. On each of the operating systems a test program (that works on the original platform) run on Python.\\\\
Test: 10.1 - Pass\\\\
Result: All operating systems were able to handle the task and in each case graphs were produced without any errors or issues.

		
\section{Comparison to Existing Implementation}	

\underline{Test: 11.1}\\\\ \label{sec:11.1}
Description: This test was compare how the XPYCharts and jCharts libraries deal with infinite range inputs. It was expected that the XPYCharts would not be able to deal with this input and an error will result. jCharts library was expected to catch this exception and output a message.\\\\

Result: PASS. The test shows that the XPYCharts library cannot deal with such inputs and so changes must be made to the how it deals with unexpected inputs. When jCharts was provided with the same input it was able to catch the exception and gave back a message.\\\\


\underline{Test: 11.2}\\\\ \label{sec:11.2}
Description:  Goal was to compare the results of entering an empty list of data into the library and compare whether XPYCharts deals with this input in a similar manner to the jCharts library.\\\\

Result: PASS. Both graphing libraries produced an empty graph when given as input an empty list of data. This means that XPYCharts faithfully recreates this aspect of the jCharts library.\\\\

\underline{Test: 11.3}\\\\
Description: This test was to compare how the two libraries deal with a long list of repeated inputs. It is expected that a good library would be able to ignore such repetitions and not take a long time by just graphing one of the inputs. In this case it is expected that jCharts would be able to deal with such a situation and would simply ignore the repetitions and not take a long time to make the graph. On the other hand it is expected that XPYCharts will take a considerably long time according to the current implementation. \\\\

Result: PASS. jCharts was able to quickly graph the input without being stalled out due to the long list of repeated inputs. XPYCharts took considerably longer to graph the same set of inputs. This was the expected output, however it means that changes must be made to the XPYCharts library to deal with such a situation.\\\\

\underline{Test: 11.4}\\\\\label{sec:11.4}
Description: This test is to compare how the two libraries deal with erroneous inputs where some of the values are (x,y,z) coordinates and not just (x,y). Recall the scope of XPYCharts only covers the XY plane. It was expected that in this case XPYCharts would simply avoid the z value and graph the tuple as a XY tuple. jCharts is expected to catch this exception return a message.\\\\

Result: PASS. XPYCharts graphs the tuple as a XY tuple as expected. However this is not ideal as an error message should be produced letting the user know that a (x,y,z) tuple cannot be expected. jCharts gives an error message as expected.\\

\section{Unit Testing}\label{sec:unittest}
\textit{For readability, inputs and outputs may not be formatted exactly as they are in unit testing}

\subsubsection{\_get\_translated\_point(self, coord)}		
	\label{sec:4.0.1}
	\paragraph{}
		\begin{enumerate}
			\item{\textbf{Test ID \#1.1\\}}
			\textbf{Initial State:} Instantiate Graph(6) object with 6 markings on each quadrant.\\
			\textbf{Input:} Dictionary with $x:= int \vee float$, $y:= int \vee float$ \\
			\textbf{Assertion:} Function returns an int or float \\
			\begin{table}[h!]
			  \centering
			  \caption{Test cases}
			  \begin{tabular}{|c|c|}
			  	\toprule
			   	 Input & Output\\
			   	 \midrule
			   	 $(1,-1) $  & $x:= int \vee float$, $y:= int \vee float$\\
			   	 $(2,1)$ &  $x:= int \vee float$, $y:= int \vee float$\\
			   	 $(-4,-3)$ & $x:= int \vee float$, $y:= int \vee float$\\

			   	 \bottomrule
			  \end{tabular}
			\end{table}

			\textbf{Result:} PASS
			
			\item{\textbf{Test ID \#1.2\\}}
			\textbf{Initial State:} Instantiate Graph(6) object with 6 markings on each quadrant.\\
			\textbf{Input:} Dictionary with $x:= int \vee float$, $y:= int \vee float$ \\
			\textbf{Assertion:} Function appropriately scales given coords \\
			\begin{table}[h!]
			  \centering
			  \caption{Test cases}
			  \begin{tabular}{|c|c|}
			  	\toprule
			   	 Input & Output\\
			   	 \midrule
			   	 $(1,-1) $  & $\lbrace y: 342, x: 342 \rbrace$\\
			   	 $(2,1)$ &  $\lbrace y: 258, x: 384 \rbrace$\\
			   	 $(-4,-3)$ & $\lbrace y: 426, x: 132 \rbrace$\\
			   	% $\lbrace  \rbrace$\\
			   	 \bottomrule
			  \end{tabular}
			\end{table}
			\textbf{Result:} PASS
			
		\end{enumerate}

\subsubsection{checktype(x, y)}		
	\label{sec:4.0.3}
	\paragraph{}
		\begin{enumerate}
			\item{\textbf{Test ID \#3.1\\}}
			\textbf{Initial State:} Empty script\\
			\textbf{Input:} Set of x and y values with $x:= int \vee float$, $y:= int \vee float$ \\
						\textbf{Assertion:} Function raises no exception \\
			\begin{table}[h!]
			  \centering
			  \caption{Test cases}
			  \begin{tabular}{|c|c|}
			  	\toprule
			   	 Input\\
			   	 \midrule
			   	 $[ (-4,4), (-2.5,1), (-1,1) , (1,1), (2,2.2), (4,5), (5,33)] $ \\
			   	 $[ (-4,6), (-3,-6), (-1,11) , (1.2,14), (2,22), (4,25), (5,13) ]$\\
			   	 $[ (-4,4), (-2,1), (-1,1) , (1,1), (2,2), (4,5), (5,33) ]$\\

			   	 \bottomrule
			  \end{tabular}
			\end{table}

			\textbf{Result:} PASS
			
			\item{\textbf{Test ID \#2.1\\}}
			\textbf{Initial State:} Empty Script.\\
			\textbf{Input:} Set of dictionaries with one member not respecting $x:= int \vee float$, $y:= int \vee float$ \\
			\textbf{Assertion:} Function raises exception \\
			
			\begin{table}[h!]
			  \centering
			  \caption{Test cases}
			  \begin{tabular}{|c|c|}
			  	\toprule
			   	 Input\\
			   	 \midrule
			   	 $[ (-4,4), (-2,1), ``cat'' , (1.1,1), (2,2), (4,5), (5,33)] $ \\
			   	 $[ (-4,6), (-3,-6), \sin , (1,14.1), (2,22), (4,25), (5,13) ]$\\
			   	 $[ (1,3,3,7), (h,4,x,0,r), (-1,1) , (1,1), (2,2), (4,5), (5,33) ]$\\

			   	 \bottomrule
			  \end{tabular}
			\end{table}
			
			\textbf{Result:} PASS
		\end{enumerate}
		
%ask sarthak
\subsubsection{is\_function(data)}		
	\label{sec:4.0.4}
	\paragraph{}
		\begin{enumerate}
			\item{\textbf{Test ID \#4.1\\}}
			\textbf{Initial State:} Empty script\\
			\textbf{Input:}  List of \\
			\textbf{Assertion:} Returns true if the given data set has no $x$ value with two different $y$ values \\
			\begin{table}[h!]
			  \centering
			  \caption{Test cases}
			  \begin{tabular}{|c|c|}
			  	\toprule
			   	 Input & Output\\
			   	 \midrule
			   	 $[ (-4,4), (-2.5,1), (-1,1) , (1,1), (2,2.2), (4,5), (5,33)] $  & True\\
			   	 $[ (-4,6), (-3,-6), (-1,11) , (1.2,14), (2,22), (4,25), (5,13) ]$ & True \\
			   	 $[ (-4,4), (-4, 5.5) ]$ & False\\
			 
			   	 \bottomrule
			  \end{tabular}
			\end{table}
			\textbf{Result:} PASS
			

		\end{enumerate}		
		

\subsubsection{clean\_data(data)}		
	\label{sec:4.0.5}
	\paragraph{}
		\begin{enumerate}
			\item{\textbf{Test ID \#5.1\\}}
			\textbf{Initial State:} Empty script\\
			\textbf{Input:} Non tuple-list variable\\
			\textbf{Assertion:} Throws Inconsistent Data error\\
			
			\textbf{Result:} PASS
			
			\item{\textbf{Test ID \#5.2\\}}
			\textbf{Initial State:} Empty script\\
			\textbf{Input:} Valid data set \\
			\textbf{Assertion:} Returns formatted list of dictionaries\\
			\begin{table}[h!]
			  \centering
			  \caption{Test cases}
			  \begin{tabular}{|c|c|}
			  	\toprule
			   	 Input & Output\\
			   	 \midrule
			   	 $[ (-4,4), (-2,1)] $  & $[\{'y':4, 'x':4\}, \{'y':1, 'x':-2\}]$\\
			   	 $[ (-4,6), (-3,-6) ]$ & [\{'y': 6, 'x': -4\}, \{'y': -6, 'x': -3\}]\\
			   	 $[ (-10,4), (0,1) ]$ & [\{'y': 4, 'x': -10\}, \{'y': 1, 'x': 0\}]\\

			   	 \bottomrule
			  \end{tabular}
			\end{table}
			\textbf{Result:} PASS

		\end{enumerate}		

\subsubsection{get\_scale(data\_set, round\_to = 0)}		
	\label{sec:4.0.5}
	\paragraph{}
		\begin{enumerate}
			\item{\textbf{Test ID \#6.1\\}}
			\textbf{Initial State:}Instantiate Graph(6) object with 6 markings on each quadrant.\\
			\textbf{Input:} Set of dictionaries with $x:= int \vee float$, $y:= int \vee float$ \\
			\textbf{Assertion:} Returns max of x and y respectively\\
			
			\begin{table}[h!]
			  \centering
			  \caption{Test cases}
			  \begin{tabular}{|c|c|}
			  	\toprule
			   	 Input & Output\\
			   	 \midrule
			   	 $[ (-4,4), (-2.5,1), (-1,1) , (1,1), (2,2.2), (4,5), (5,33.5)] $  & $[5, 33.5]$\\
			   	 $[ (-4,6), (-3,-6), (-1,11) , (1.2,14), (2,22), (4,25), (5,13) ]$ & $[5, 25]$ \\
			   	 $[ (-4,4), (-4, 5.5) ]$ & $[4, 5.5]$\\
			 
			   	 \bottomrule
			  \end{tabular}
			\end{table}
			
			\textbf{Result:} PASS
			
			\item{\textbf{Test ID \#5.2\\}}
			\textbf{Initial State:} Empty script\\
			\textbf{Input:} Set of dictionaries with $x:= int \vee float$, $y:= int \vee float$ . round\_to $\neq 0$ \\
						\textbf{Assertion:}  Returns max of x and y respectively. Return values are multiples of round\_to \\
			
			\begin{table}[h!]
			\small
			  \centering
			  \caption{Test cases}
			  \begin{tabular}{|c|c|}
			  	\toprule
			   	 Input & Output\\
			   	 \midrule
			   	 $[ (-4,4), (-2.5,1), (-1,1) , (1,1), (2,2.2), (4,5), (5,33.5)], round\_to = 2 $  & $[6, 34.0]$\\
			   	 $[ (-4,6), (-3,-6), (-1,11) , (1.2,14), (2,22), (4,25), (5,13) ]], round\_to = 7 $ & $[7, 28]$ \\
			   	 $[ (-4,4), (-4, 5.5) ]$ & $[5, 6.0]], round\_to = 1$\\
			   	 \bottomrule
			  \end{tabular}
			\end{table}
			

			\textbf{Result:} PASS

		\end{enumerate}	



\section{Changes Due to Testing}

As seen in the Area of Testing \hyperref[sec:3.1]{3.1} and \hyperref[sec:3.2]{3.2} for Functional Requirements Evaluation, the test cases had failed to produce the expected output. 

After manual code evaluation, it was realized by the developers that this was because an instantiated graph defaults to drawing the axes under the assumption of the data given to it. Because the test case was instantiating the Graph object with NoneType data, the graph would default to drawing the axes with a scale of 1 (therefore, the max values of magnitude 6, for the 6 markings). When calling the plot\_...() methods, it would draw on a canvas already painted in the initializer. 

To fix this, a few extra lines were added to the plot\_...() methods where they would call the init() method to reinitialize the graph canvas and paint it with the appropriate axes. 
\textbf{The two test cases passed once these changes were complete.}  \\

Additionally, according to the results of test case \hyperref[sec:8.2]{8.2} changes were made to the input parser to output better error messages so that the users can understand what they did wrong while inputting the data.
\section{Automated Testing}
Because of the timeframe of the project, the extent of the automated testing was \hyperref[sec:unittest]{unit testing}, and testing of source code (seen in the test case below) using the online tool \href{https://www.pylint.org}{Pylint}.



\subsubsection{Area of Testing 5}		
	\paragraph{Testing of source code.}
		\begin{enumerate}
			\item{\textbf{Test ID \#5.1\\}}
			\textbf{Type:} Functional, Static, Automated\\
			\textbf{Initial State:} Completed source code. \\
			\textbf{Input:} Source code.\\
			\textbf{Expected Output:} Review of source code.\\
			\textbf{Output:}	 \href{run:code_eval.txt} {\underline{log-file}}.\\
			\textbf{Result:} N/A
		\end{enumerate}

It would not have been feasible to do bitmap comparison automated testing for this project because to do so correctly and accurately would have been out of the scope of the project. The developers verified the outputs of the graphs manually to realize that the behavior was up to expectations, and the challenge in the nature of this sort of automated testing would not have been worth the value compared to the time dedicated to it, especially to realize an outcome that was already manually verified.



\section{Trace to Requirements} %Louis

\begin{table}[h!]
\centering
\begin{tabular}{p{0.2\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Test ID} & \textbf{Requirement}\\
\midrule
\multicolumn{2}{c}{Functional Requirements Testing} \\
\midrule
1 & R1, R4 \\
2 & R2 \\
3 & R3 \\
4 & R5 \\

\midrule
\multicolumn{2}{c}{Non-functional Requirements Testing} \\
\midrule

7 & RNF1\\
8.1 & RNF2, RNF3, RNF4, RNF5\\
8.2 & RNF5\\
9 &  RNF6, RNF9, RNF10\\
10.1 & RNF11, RNF12, RNF13, RNF15\\
\midrule
\multicolumn{2}{c}{Comparison to Existing Implementation} \\
\midrule
11.1 & R1, R2\\
11.2 & R3\\
11.3 & RNF6, RNF8\\
11.4 & RNF6, RNF8, RNF10\\
\bottomrule
\end{tabular}
\caption{Trace Between Tests and Requirements}
\end{table}

\pagebreak
		
\section{Trace to Modules} %Louis 

\begin{table}[h!]
\centering
\begin{tabular}{p{0.2\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Test} & \textbf{Module}\\
\midrule
\multicolumn{2}{c}{Functional Requirements Testing} \\
\midrule
1 & M1, M3.1, M3.3, M2.2, M1.1 \\
2 & M2.1 \\
3 & M3.3 \\
4 & M3.2, M1.1 \\
\midrule
\multicolumn{2}{c}{Non-functional Requirements Testing} \\
\midrule
7 & M1.1\\
8.1 & M1, M2.1, M3\\
8.2 & M2.1\\
9.1 &  M1, M2.3, M3\\
10.1 & M1\\
\midrule
\multicolumn{2}{c}{Comparison to Existing Implementation} \\
\midrule
11.1 & M3.1\\
11.2 & M3.1, M2.1\\
11.3 & M2.2, M3.2, M3.3 \\
11.4 & M2.1\\
\bottomrule
\end{tabular}
\caption{Trace Between Modules and Tests}
\end{table}
		

\section{Code Coverage Metrics}
Code coverage metrics are important in showing the extent of the testing that the project underwent. We decided to use line coverage as our coverage metric. This is easiest to implement given the nature of the project. Manually examining the execution of our tests determined that 99\% line coverage was achieved. This surpasses our original goal of 90\% code coverage, and should be considered a success. The few lines that were not covered were trivial try/except blocks that do not currently require testing. As the project expands, these sections may become more relevant, and code coverage should be reexamined in future iterations. 

More in depth code coverage analysis, with the python coverage.py application , was not possible due to the reliance of this project on the TKinter library, and the graphical nature of the project.
\bibliographystyle{plainnat}
\bibliography{SRS}
\end{document}